---
title: 变量、作用域与内存
autoGroup-1: JS高级程序设计
sidebarDepth: 0
autoSort: 997
---

### 原始值与引用值
ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。    
- 原始值大小固定，因此保存在栈内存上   
- 引用值是对象，存储在堆内存上   

typeof操作符可以确定值的原始类型，而instanceof操作符用于确保值的引用类型。

::: tip 注意
在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript打破了这个惯例。    
:::

函数参数中对象也是按值传递的，例：    
```js
function setName(obj) {
  obj.name = "Nicholas";
  obj=newObject();
  obj.name="Greg";
}
let person = new Object();
setName(person);
console.log(person.name);   // "Nicholas"
```

::: tip 注意
ECMAScript中函数的参数就是局部变量。    
:::

::: tip 注意
typeof操作符在用于检测函数时也会返回"function"。    
当在Safari（直到Safari 5）和Chrome（直到Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof也会返回"function"。    
ECMA-262规定，任何实现内部[[Call]]方法的对象都应该在typeof检测时返回"function"。     
因为上述浏览器中的正则表达式实现了这个方法，所以typeof对正则表达式也返回"function"。在IE和Firefox中，typeof对正则表达式返回"object"。   
:::

### 执行上下文与作用域   
全局上下文的变量对象始终是作用域链的最后一个变量对象。   
内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。   
例：
```js
var color = "blue";
function changeColor() {
  let anotherColor = "red";
  function swapColors() {
    let tempColor = anotherColor;
    anotherColor = color;
    color = tempColor;
    // 这里可以访问color、anotherColor和tempColor
  }
  // 这里可以访问color和anotherColor，但访问不到tempColor
  swapColors();
}
// 这里只能访问color
changeColor();
```
::: tip 注意
函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。   
:::

#### 作用域链增强   
某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时：
- try/catch语句的catch块    
  则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明        
- with语句    
  会向作用域链前端添加指定的对象    
  
#### 变量声明   
在使用var声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文。   

var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。   
::: tip 注意
var在for循环中会泄露是因为变量提升。   
::: 

ES6新增的let关键字跟var很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号{}界定。  

#### 垃圾回收   
JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。   
垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。   

如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：    
- 标记清理   
  垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存     
- 引用计数   
  对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存    

  严重的问题：循环引用   

在IE8及更早版本的IE中，并非所有对象都是原生JavaScript对象。BOM和DOM中的对象是C++实现的组件对象模型（COM, Component Object Model）对象，而COM对象使用引用计数实现垃圾回收。    
IE9把BOM和DOM对象都改成了JavaScript对象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象。   

::: tip 注意   
解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。   
:::

##### 内存泄漏   
- 意外声明全局变量是最常见但也最容易修复的内存泄漏问题    
  例：
  ```js
  function setName() {
    name = 'Jake';
  }
  ```
- 定时器也可能会悄悄地导致内存泄漏         
  ```js
  let name = 'Jake';
  setInterval(() => {
    console.log(name);
  }, 100);
  ```
- 使用JavaScript闭包很容易在不知不觉间造成内存泄漏     
  ```js
  let outer = function() {
    let name = 'Jake';
    return function() {
      return name;
    };
  };
  ```

##### 静态分配与对象池   
理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。   

浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。   
::: tip 注意  
静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。  
:::