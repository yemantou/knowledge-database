---
title: 作用域是什么
autoGroup-1: 你不知道的JS
sidebarDepth: 0
autoSort: 100
---

### 编译原理   
  尽管通常将JavaScript归类为“动态”或“解释执行”语言，但事实上它是一门编译语言<font color=Red>（对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内）</font>。   

### 编译
  - 分词/词法分析（Tokenizing/Lexing）  
    如果词法单元生成器在判断a是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。     
  - 解析/语法分析（Parsing）   
    这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（AbstractSyntax Tree, AST）。          
  - 代码生成   
    将AST转换为可执行代码的过程被称为代码生成；这个过程与语言、目标平台等息息相关。

### 理解作用域   
  - 成员  
    - 引擎  
      从头到尾负责整个JavaScript程序的编译及执行过程。    
    - 编译器
      负责语法分析及代码生成等脏活累活。  
    - 作用域  
      负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。    
  - 对话，例如：var = 2  
    变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。  
  - LHS与RHS查询  
    RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值<font color=Red>（赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”）</font>。  

### 作用域嵌套  
  当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。  

### 异常  
  - 区分LHS和RHS，在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。  
    - RHS：如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。  
    - LHS：当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。  
    - <font color=Red>ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</font>      

### 小结
  - 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）  
    - 如果查找的目的是对变量进行赋值，那么就会使用LHS查询；  
      赋值操作符会导致LHS查询。=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。  
    - 如果目的是获取变量的值，就会使用RHS查询。  
  - JavaScript引擎首先会在代码执行前对其进行编译，在这个过程中，像var a =2这样的声明会被分解成两个独立的步骤：  
    - 1．首先，var a在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。  
    - 2．接下来，a = 2会查询（LHS查询）变量a并对其进行赋值。  
  - LHS和RHS查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。  
    - 不成功的RHS引用会导致抛出ReferenceError异常。  
    - 不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常（严格模式下）。   

