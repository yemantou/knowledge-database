---
title: 强制类型转换
autoGroup-1: 你不知道的JS
sidebarDepth: 0
autoSort: 83
---

### 值类型转换
将值从一种类型转换为另一种类型通常称为类型转换（type casting），这是显式的情况；隐式的情况称为强制类型转换（coercion）。  
::: tip 
类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时（runtime）。  
:::
```js
var a = 42;

var b = a + ''; // 隐式强制类型转换

var c = String(a); // 显式强制类型转换
```

### 抽象值操作
1. ToString  
   toJSON()应该“返回一个能够被字符串化的安全的JSON值”，而不是“返回一个JSON字符串”。  
   - 可以向JSON.stringify(..)传递一个可选参数replacer，它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除。  
   - 如果replacer是一个数组，那么它必须是一个字符串数组，其中包含序列化要处理的对象的属性名称，除此之外其他的属性则被忽略。  
   - JSON.stringify还有一个可选参数space，用来指定输出的缩进格式。space为正整数时是指定每一级缩进的字符数，它还可以是字符串，此时最前面的十个字符被用于每一级的缩进。  

   JSON.stringify(..)并不是强制类型转换。在这里介绍是因为它涉及ToString强制类型转换，具体表现在以下两点。   
   (1) 字符串、数字、布尔值和null的JSON.stringify(..)规则与ToString基本相同。  
   (2) 如果传递给JSON.stringify(..)的对象中定义了toJSON()方法，那么该方法会在字符串化前调用，以便将对象转换为安全的JSON值。  
2. ToNumber  
   其中true转换为1, false转换为0。undefined转换为NaN, null转换为0。  
   ToNumber对以0开头的十六进制数并不按十六进制处理（而是按十进制）。   
   对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。  
   为了将值转换为相应的基本类型值，抽象操作ToPrimitive会首先检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用toString()的返回值（如果存在）来进行强制类型转换。  
   如果valueOf()和toString()均不返回基本类型值，会产生TypeError错误。   
3. ToBoolean  
   我们常误以为数值1和0分别等同于true和false。在有些语言中可能是这样，但在JavaScript中布尔值和数字是不一样的。虽然它们之间可以相互转换，但不是一回事。
   - 假值（falsy value）  
     js中的值可以分为两类：
     (1) 可以被强制类型转换为false的值  
     (2) 其他（被强制类型转换为true的值）  
     以下这些是假值（假值的布尔强制类型转换结果为false）：  
     - undefined
     - null
     - false
     - +0、-0和NaN
     - ""  
     ::: danger 警告
     document.all现在它是一个假值对象。  
     :::
   - 真值（truthy value）  
     真值就是假值列表之外的值。  

### 显式强制类型转换
#### 字符串和数字之间的显式转换
一元运算符+会将操作数显式强制类型转换为数字：  
```js
var c = '3.14';

var d = +c; // +c是+运算符的一元（unary）形式（即只有一个操作数）

console.log(d); // 3.14
```   
1. 日期显式转换为数字
   一元运算符+的另一个常见用途是将日期（Date）对象强制类型转换为数字，返回结果为Unix时间戳，以毫秒为单位（从1970年1月1日00:00:00 UTC到当前时间）。  
   获得当前的时间戳：  
   ```js
   var timestamp = +new Date();
   ```
   将日期对象转换为时间戳的其他方法：  
    ```js
   var timestamp = +new Date().getTime();

   // ES5可用
    var timestamp = Date.now();
   ```
2. 奇特的`~`运算符  
   `~`首先将值强制类型转换为32位数字，然后执行字位操作“非”（对每一个字位进行反转）。  
   另外一种诠释，源自早期的计算机科学和离散数学：`~`返回2的补码，`~x`大致等同于`-(x+1)`  
   `~`和`indexOf()`一起可以将结果强制类型转换（实际上仅仅是转换）为真/假值（JS中数字负数为 true，0 和 -0才是false）：  
   ```js
   var a = 'Hello World';

   console.log(~a.indexOf('lo')); // -4

   if (~a.indexOf('lo')) { // true
     console.log('找到了 lo 的匹配');
   }

   console.log(~a.indexOf('ol')); // 0
   console.log(!~a.indexOf('ol')); // true

   if (!~a.indexOf('ol')) { // true
    console.log('没有找到 ol 的匹配');
   }
   ```
   ::: tip 提示
   indexOf(..)返回-1, ~将其转换为假值0，其他情况一律转换为真值。  
   :::
3. 字位截除  
   使用~~来截除数字值的小数部分，能将值截除为一个32位整数。  
   ```js
   console.log(~~49.6); // 49 向下取整

   console.log(Math.floor(49.6)); // 49 向下取整

   console.log(~~-49.6); // -49 负数与Math.floor(...)不同

   console.log(Math.floor(-49.6)); // -50 向下取整
   ```
#### 显式解析数字字符串
解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。但解析和转换两者之间还是有明显的差别。  
解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。  
转换不允许出现非数字字符，否则会失败并返回NaN。  
```js
var a = '42';
var b = '42px';

console.log(Number(a)); // 42
console.log(parseInt(a)); // 42

console.log(Number(b)); // NAN
console.log(parseInt(b)); // 42
``` 

::: danger 注意
ES5之前的parseInt(..)有一个坑导致了很多bug。即如果没有第二个参数来指定转换的基数（又称为radix）, parseInt(..)会根据字符串的第一个字符来自行决定基数。  
如果第一个字符是x或X，则转换为十六进制数字。如果是0，则转换为八进制数字。   
`parseInt(08)`结果为 0 ，因为 8 不是有效的八进制数。  
将第二个参数设置为10，即可避免这个问题。  
ES5开始parseInt(..)默认转换为十进制数，除非另外指定。   
:::

### 解析非字符串
parseInt(..)的一个坑：   
```js
parseInt(1/0, 19);
```
如果第一个参数值为Infinity，解析结果也应该是Infinity（实际上大错特错）；  
不应该向parseInt(..)传递非字符串。如果是非字符串：parseInt(..)先将参数强制类型转换为字符串再进行解析。  
parseInt(1/0, 19)实际上是parseInt("Infinity", 19)。第一个字符是"I"，以19为基数时值为18。第二个字符"n"不是一个有效的数字字符，解析到此为止，和"42px"中的"p"一样。  

### 隐式强制类型转换
隐式强制类型转换真是如此不堪吗？它是不是JavaScript语言的设计缺陷？我们是否应该对其退避三舍？其实不然。  
::: tip 提示
隐式强制类型转换的作用是减少冗余，让代码更简洁。  
:::
#### 隐式地简化
```js
// 伪代码
SomeType x = SomeType(AnotherType(y));
```
变量y的值被转换为SomeType类型，但是语言本身不允许直接将y转换为SomeType类型。于是我们需要一个中间步骤，先将y转换为AnotherType类型，然后再从AnotherType转换为SomeType。  
如果可以像下面这样就更简洁了，无关紧要的中间步骤可以也应该被隐藏：  
```js
// 伪代码
SomeType x = SomeType(y);
```
::: danger 警告
式强制类型转换同样可以用来提高代码可读性，但隐式强制类型转换也会带来一些负面影响，有时甚至是弊大于利。因此我们更应该学习怎样去其糟粕，取其精华。
:::
#### 字符串和数字之间的隐式强制类型转换
通过重载，+运算符即能用于数字加法，也能用于字符串拼接，例如：  
```js
var a = '42';
var b = '0';

var c = 42;
var d = 0;

console.log(a + b); // '420'
console.log(c + d); // 42
```
原因：因为某一个或者两个操作数都是字符串，所以+执行的是字符串拼接操作（只解释了一半，实际情况要复杂得多）。   
例如：  
```js
var a = [1, 2];
var b = [3, 4];

console.log(a + b); // 1,23,4
```
a和b都不是字符串，但是它们都被强制转换为字符串然后进行拼接。原因是：  
根据ES5规范11.6.1节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+将进行拼接操作：  
- 如果其中一个操作数是对象（包括数组），则首先对其调用ToPrimitive抽象操作（规范9.1节），该抽象操作再调用[[DefaultValue]]（规范8.12.8节），以数字作为上下文。  
- 数组的valueOf()操作无法得到简单基本类型值，于是它转而调用toString()。因此上例中的两个数组变成了"1,2"和"3,4"。+将它们拼接后返回"1,23,4"。
- 简单来说就是，如果+的其中一个操作数是字符串（或者通过以上步骤可以得到字符串），则执行字符串拼接；否则执行数字加法。    
::: danger 警告
[] + {}和{} + []，它们返回不同的结果，分别是"[object Object]"和0（语法目录部分进行详细解释）。  
:::
a + ""（隐式）和前面的String(a)（显式）之间有一个细微的差别需要注意：  
- 根据ToPrimitive抽象操作规则，a + ""会对a调用valueOf()方法，然后通过ToString抽象操作将返回值转换为字符串。  
- String(a)则是直接调用ToString()。  
最后返回的都是字符串，但如果a是对象而非数字结果可能会不一样！例如：  
```js
var a = {
  valueOf: function () { return 42; },
  toString: function () { return 4; }
};

console.log(a + '');
console.log(String(a));
```
::: danger 注意
在定制valueOf()和toString()方法时需要特别小心，因为这会影响强制类型转换的结果。  
:::

#### ||和&&
&&和||运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值。  
- ||  
  如果条件判断结果为true就返回第一个操作数的值，如果为false就返回第二个操作数的值。  
- &&  
  如果条件判断结果为true就返回第二个操作数的值，如果为false就返回第一个操作数的值。  

::: tip 提示
返回的不是true和false，为什么a && (b || c)这样的表达式在if和for中没出过问题？  
因为这些条件判断表达式最后还会执行布尔值的隐式强制类型转换。
:::  

#### 符号的强制类型转换
ES6允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。例如：  
```js
var s1 = Symbol('cool');
console.log(String(s1)); // 'Symbol(cool)'

var s2 = Symbol('not cool');
console.log(s2 + ''); // TypeError
```
符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是true）。  

### 宽松相等和严格相等
宽松相等（loose equals）==和严格相等（strict equals）===都用来判断两个值是否“相等。  
::: danger 误区
常见的误区是“==检查值是否相等，===检查值和类型是否相等”。  
:::
正确的解释是：“==允许在相等比较中进行强制类型转换，而===不允许。”   
#### 相等比较操作的性能
==和===几乎没有区别。  
==和===都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。  
#### 抽象相等
ES5规范11.9.3节的“抽象相等比较算法”定义了==运算符的行为。该算法简单而又全面，涵盖了所有可能出现的类型组合，以及它们进行强制类型转换的方式。  
如果两个值的类型相同，就仅比较它们是否相等。  
几个非常规的情况需要注意：  
- NaN不等于NaN
- +0等于-0 
两个对象指向同一个值时即视为相等，不发生强制类型转换。实际上在比较两个对象的时候，==和===的工作原理是一样的。  
==在比较两个不同类型的值时会发生隐式强制类型转换，会将其中之一或两者都转换为相同的类型后再进行比较。  
#### 其他类型和布尔类型之间的相等比较
(1) 如果Type(x)是布尔类型，则返回ToNumber(x) == y的结果；  
(2) 如果Type(y)是布尔类型，则返回x == ToNumber(y)的结果。  
#### null和undefined之间的相等比较
(1) 如果x为null, y为undefined，则结果为true。  
在==中null和undefined相等（它们也与其自身相等）
(2) 如果x为undefined, y为null，则结果为true。  
#### 比较少见的情况
1．返回其他数字
```js
Number.prototype.valueOf = function () {
  return 3;
};

console.log(new Number(2) == 3); // true
```
2 == 3不会有这种问题，因为2和3都是数字基本类型值，不会调用Number.prototype.valueOf()方法。而Number(2)涉及ToPrimitive强制类型转换，因此会调用valueOf()。  

a.valueOf()每次调用都产生副作用，比如第一次返回2，第二次返回3：  
```js
var i = 2;

Number.prototype.valueOf = function () {
  return i++;
};

var a = new Number(42)

console.log(a == 2 && a == 3); // true
```

::: danger 警告
对一种机制的滥用并不能成为诟病它的借口。我们应该正确合理地运用强制类型转换，避免这些极端的情况。  
:::
#### 假值的相等比较
==中的隐式强制类型转换最为人诟病的地方是假值的相等比较。  
7种意外情况（结果均为true）：  
1. '0' == false
2. false == 0
3. false == ''
4. false == []
5. '' == 0
6. '' == []
7. 0 == []
#### 安全运用隐式强制类型转换
- 如果两边的值中有true或者false，千万不要使用==。  
- 如果两边的值中有[]、""或者0，尽量不要使用==。  

### 抽象关系比较
a < b涉及了隐式强制类型转换。  
比较双方首先调用ToPrimitive，如果结果出现非字符串，就根据ToNumber规则将双方强制类型转换为数字来进行比较。  