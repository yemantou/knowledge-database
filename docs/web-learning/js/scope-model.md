---
title: 作用域（两种主要的工作模型）
autoGroup-1: 你不知道的JS
sidebarDepth: 0
autoSort: 99
---

### 词法作用域   
#### 词法阶段
- 词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。  
  - 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）；   
  - 抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止；  
  - 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定；  
  - 词法作用域查找只会查找一级标识符，比如a、b和c。如果代码中引用了foo.bar.baz，词法作用域查找只会试图查找foo标识符，找到这个变量后，对象属性访问规则会分别接管对bar和baz属性的访问。   

#### 欺骗词法
- eval   
  eval(..)函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。  
- with   
  with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。  
  ```javascript
  var obj = {
    a: 1,
    b: 2,
    c: 3
  };
  // 普通修改值
  obj.a = 2;
  obj.b = 3;
  obj.c = 4;
  // 简单的快捷方式
  with (obj) {
    a = 3;
    b = 4;
    c = 5;
  }
  ```
::: tip 提示
eval(..)和with的会被严格模式所影响（限制）。with被完全禁止，而在保留核心功能的前提下，间接或非安全地使用eval(..)也被禁止了。   
两个机制的副作用是引擎无法在编译时对作用域查找进行优化。如果代码中大量使用eval(..)或with，那么运行起来一定会变得非常慢。   
::: 

### 动态作用域   
- 词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。   