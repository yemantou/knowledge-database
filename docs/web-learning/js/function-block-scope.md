---
title: 函数作用域和块作用域
autoGroup-1: 你不知道的JS
sidebarDepth: 0
autoSort: 98
---

### 隐藏内部实现
::: tip 备注
函数声明对代码进行包装，实际上就是把这些代码“隐藏”起来了，在这个代码片段的周围创建了一个作用域气泡。  
::: 

  #### 规避冲突（避免同名标识符之间的冲突）
  - 全局命名空间
    多个第三方库，如果内部私有的函数或变量未妥善隐藏起来，容易引发冲突。通常会在全局作用域中声明一个名字足够独特的变量。   
  - 模块管理
    通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。 

### 函数作用域

  #### 匿名和具名
  - 匿名函数缺点   
    - 1．匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难；   
    - 2．如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身；   
    - 3．匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。   
    ::: tip 解决方法
    给函数表达式指定一个函数名可以有效解决问题。   
    :::

  #### 立即执行函数表达式（IIFE）
  ```js
  var a = 2;

  (function foo() {
    var a = 3;
    console.log(a); // 3
  })();

  console.log(a); // 2
  ```
  - 进阶用法：当作函数调用并传递参数进去
    ```js
    var a = 2;

    (function IIFE(global) {
      var a= 3;
      console.log(a); // 3
      console.log(global.a); // 2
    })(window);

    console.log(a); // 2
    ```
  - 另一种变化的用途：倒置代码的运行顺序（将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去）
    ```js
    var a = 2;

    (function IIFE(def) {
      def(window);
    })(function def(global) {
      var a= 3;
      console.log(a); // 3
      console.log(global.a); // 2
    });
    ```
### 块作用域
- with
用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效。   
- try/catch   
try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。   
- let  
let为其声明的变量隐式地劫持了所在的块作用域，使用let进行的声明不会在块作用域中进行提升。  
- 垃圾收集  
闭包及回收内存垃圾的回收机制。  