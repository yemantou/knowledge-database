---
title: 异步
autoGroup-1: 你不知道的JS
sidebarDepth: 0
autoSort: 82
---

### 分块的程序
只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点击、Ajax响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制。  

### 事件循环
用户交互、IO和定时器会向事件队列中加入事件。   
JavaScript引擎本身所做的只不过是在需要的时候，在给定的任意时刻执行程序中的单个代码块。  
“需要”，谁的需要？这正是关键所在！  
事件循环伪代码示例：  
```js
// eventLoop是一个用作队列（先进先出）的数组
var eventLoop = [];
var myevent;

// 永远执行
while (true) {
  // 一次tick 
  if (eventLoop.length > 0) {
    // 拿到队列中的下一个事件
    myevent = eventLoop.shift();

    // 执行下一个事件
    try {
      myevent();
    } catch (err) {
      reportError(err);
    }
  }
}
```
有一个用while循环实现的持续运行的循环，循环的每一轮称为一个tick。对每个tick而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。这些事件就是你的回调函数。  

::: tip 提示
setTimeout(..)并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的tick会摘下并执行这个回调。  
:::

### 并行线程
异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情。  
并行计算最常见的工具就是进程和线程。进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。  
事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。  
```js
var a = 20;

function foo() {
  a = a + 1;
}

function bar() {
  a = a * 2;
}

// ajax(..)是某个库中提供的某个Ajax函数
ajax('http://url.1', foo);
ajax('http://url.2', bar);
```
由于JavaScript的单线程特性，foo()（以及bar()）中的代码具有原子性。也就是说，一旦foo()开始运行，它的所有代码都会在bar()中的任意代码运行之前完成，或者相反。这称为完整运行（run-to-completion）特性。  

### 任务
在ES6中，有一个新的概念建立在事件循环队列之上，叫作任务队列（job queue）。  
任务队列：它是挂在事件循环队列的每个tick之后的一个队列。在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前tick的任务队列末尾添加一个项目（一个任务）。  

事件循环队列类似于一个游乐园游戏：玩过了一个游戏之后，你需要重新到队尾排队才能再玩一次。而任务队列类似于玩过了游戏之后，插队接着继续玩。

### 小结
一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个tick。**用户交互、IO**和**定时器**会向事件队列中加入事件。  
任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一个或多个后续事件。并发是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时在运行（尽管在任意时刻只处理一个事件）。   
通常需要对这些并发执行的“进程”（有别于操作系统中的进程概念）进行某种形式的交互协调，比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身分割为更小的块，以便其他“进程”插入进来。