(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{344:function(t,a,r){"use strict";r.r(a);var s=r(15),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"浏览器的垃圾回收机制-garbage-collection"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的垃圾回收机制-garbage-collection"}},[t._v("#")]),t._v(" 浏览器的垃圾回收机制（Garbage Collection）")]),t._v(" "),r("p",[t._v("GC 即 Garbage Collection ，程序工作过程中会产生很多 垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 GC 就是负责回收垃圾的。")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[t._v("参考文章")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.cn/post/6981588276356317214",target:"_blank",rel:"noopener noreferrer"}},[t._v("你真的了解垃圾回收机制吗"),r("OutboundLink")],1)])]),t._v(" "),r("h2",{attrs:{id:"两种垃圾回收策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#两种垃圾回收策略"}},[t._v("#")]),t._v(" 两种垃圾回收策略")]),t._v(" "),r("h3",{attrs:{id:"标记清除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标记清除"}},[t._v("#")]),t._v(" 标记清除")]),t._v(" "),r("p",[t._v("标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。")]),t._v(" "),r("h4",{attrs:{id:"缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点：")]),t._v(" "),r("ul",[r("li",[t._v("内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。")]),t._v(" "),r("li",[t._v("分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。")])]),t._v(" "),r("h4",{attrs:{id:"缺点补充"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点补充"}},[t._v("#")]),t._v(" 缺点补充：")]),t._v(" "),r("p",[t._v("而 标记整理（Mark-Compact）算法 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存。")]),t._v(" "),r("h3",{attrs:{id:"引用计数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[t._v("#")]),t._v(" 引用计数")]),t._v(" "),r("p",[t._v("把对象是否不再需要简化定义为对象有没有其他对象引用到它。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。")]),t._v(" "),r("h4",{attrs:{id:"缺点-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[t._v("#")]),t._v(" 缺点：")]),t._v(" "),r("ul",[r("li",[t._v("需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。")]),t._v(" "),r("li",[t._v("解决不了循环引用导致的无法回收问题。")])]),t._v(" "),r("h3",{attrs:{id:"v8-的垃圾回收机制也是基于标记清除算法-不过对其做了一些优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#v8-的垃圾回收机制也是基于标记清除算法-不过对其做了一些优化"}},[t._v("#")]),t._v(" V8 的垃圾回收机制也是基于标记清除算法，不过对其做了一些优化")]),t._v(" "),r("p",[t._v("V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域。"),r("br"),t._v("\n新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。")]),t._v(" "),r("ul",[r("li",[t._v("针对新生区采用并行回收。")]),t._v(" "),r("li",[t._v("针对老生区采用增量标记与-惰性回收。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);