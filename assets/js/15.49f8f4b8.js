(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{286:function(t,r,s){t.exports=s.p+"assets/img/macro-micro.3344ed69.png"},339:function(t,r,s){"use strict";s.r(r);var a=s(15),e=Object(a.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步"}},[t._v("#")]),t._v(" 异步")]),t._v(" "),a("h2",{attrs:{id:"event-loop-事件循环-、宏任务和微任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-事件循环-、宏任务和微任务"}},[t._v("#")]),t._v(" event loop（事件循环）、宏任务和微任务")]),t._v(" "),a("p",[a("strong",[t._v("事件循环是js实现异步的一种方法，也是js的执行机制。")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考视频")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.bilibili.com/video/BV1oV411k7XY/?spm_id_from=333.788.recommend_more_video.-1",target:"_blank",rel:"noopener noreferrer"}},[t._v("什么是event loop"),a("OutboundLink")],1),a("br"),t._v(" "),a("a",{attrs:{href:"http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D",target:"_blank",rel:"noopener noreferrer"}},[t._v("JS代码执行流程网站"),a("OutboundLink")],1)])]),t._v(" "),a("h4",{attrs:{id:"js代码运行的顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js代码运行的顺序"}},[t._v("#")]),t._v(" JS代码运行的顺序")]),t._v(" "),a("ol",[a("li",[t._v("JS代码按顺序进入调用栈执行")]),t._v(" "),a("li",[t._v("遇到异步代码入栈后马上出栈到 Web APIs 中创建线程开始执行")]),t._v(" "),a("li",[t._v("异步代码执行完毕后进入任务队列")]),t._v(" "),a("li",[t._v("任务队列中的任务等待调用栈清空后进入调用栈执行")])]),t._v(" "),a("h3",{attrs:{id:"宏任务和微任务-任务队列中分为宏任务和微任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务-任务队列中分为宏任务和微任务"}},[t._v("#")]),t._v(" 宏任务和微任务（任务队列中分为宏任务和微任务）")]),t._v(" "),a("p",[t._v("异步任务主要分为宏任务与微任务两种。ES6 规范中，宏任务（Macrotask） 称为 Task， 微任务（Microtask） 称为 Jobs。宏任务是由宿主（浏览器、Node）发起的，而微任务由 JS 自身发起。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("参考文章")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6844903512845860872",target:"_blank",rel:"noopener noreferrer"}},[t._v("这一次，彻底弄懂 JavaScript 执行机制"),a("OutboundLink")],1),a("br"),t._v(" "),a("a",{attrs:{href:"https://juejin.cn/post/6844904165462769678",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("哪些是宏任务，哪些是微任务？"),a("br"),t._v(" "),a("img",{attrs:{src:s(286),alt:"图示"}})]),t._v(" "),a("h3",{attrs:{id:"如何理解-script-整体代码块-是个宏任务呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-script-整体代码块-是个宏任务呢"}},[t._v("#")]),t._v(" 如何理解 script（整体代码块）是个宏任务呢")]),t._v(" "),a("p",[t._v("实际上如果同时存在两个 script 代码块，会首先在执行第一个 script 代码块中的同步代码，如果这个过程中创建了微任务并进入了微任务队列，第一个 script 同步代码执行完之后，会首先去清空微任务队列，再去开启第二个 script 代码块的执行。所以这里应该就可以理解 script（整体代码块）为什么会是宏任务。")]),t._v(" "),a("h3",{attrs:{id:"事件循环-event-loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环-event-loop"}},[t._v("#")]),t._v(" 事件循环（event loop）")]),t._v(" "),a("ol",[a("li",[t._v("JS代码按顺序进入调用栈执行，遇到异步代码入栈后马上出栈到 Web APIs 中创建线程开始执行，异步代码执行完毕后回调进入任务队列（宏任务和微任务队列）")]),t._v(" "),a("li",[t._v("微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；"),a("br"),t._v(" "),a("strong",[t._v("(执行过程中产生的新的微任务添加到微任务队列中一起清空，微任务队列没清空之前，是不会执行下一个宏任务的)")])]),t._v(" "),a("li",[t._v("当微任务队列清空后，一个事件循环结束；")]),t._v(" "),a("li",[t._v("接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，宏任务执行完后再次进行2步骤内容，直至宏任务队列清空为止。")])]),t._v(" "),a("h3",{attrs:{id:"页面渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页面渲染"}},[t._v("#")]),t._v(" 页面渲染")]),t._v(" "),a("p",[a("strong",[t._v("每次当一次事件循环结束后，即一个宏任务执行完成后以及微任务队列被清空后，浏览器就会判断需不需要更新渲染，需要就会进行一次页面更新渲染。")])]),t._v(" "),a("p",[t._v("通常我们浏览器页面刷新频率是60fps，也就是意味着16.67ms要刷新一次，因此我们也要尽量保证一次事件循环控制在16.67ms之内，这也是我们"),a("strong",[t._v("需要做代码性能优化的一个原因")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[t._v("#")]),t._v(" Promise")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("学习参考文章")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/promise",target:"_blank",rel:"noopener noreferrer"}},[t._v("Promise 对象"),a("OutboundLink")],1),a("br"),t._v(" "),a("a",{attrs:{href:"https://juejin.cn/post/6945319439772434469#heading-0",target:"_blank",rel:"noopener noreferrer"}},[t._v("从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节"),a("OutboundLink")],1),a("br"),t._v(" "),a("a",{attrs:{href:"https://juejin.cn/post/6844904077537574919",target:"_blank",rel:"noopener noreferrer"}},[t._v("要就来45道Promise面试题一次爽到底"),a("OutboundLink")],1)])]),t._v(" "),a("h2",{attrs:{id:"async-await-和-promise-的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async-await-和-promise-的关系"}},[t._v("#")]),t._v(" async/await 和 Promise 的关系")]),t._v(" "),a("ul",[a("li",[t._v("async/await 是消灭异步回调的终极武器。")]),t._v(" "),a("li",[t._v("但和 Promise 并不互斥，反而，两者相辅相成。")]),t._v(" "),a("li",[t._v("执行 async 函数，返回的一定是 Promise 对象。")]),t._v(" "),a("li",[t._v("await 相当于 Promise 的 then。")]),t._v(" "),a("li",[t._v("try...catch 可捕获异常，代替了 Promise 的 catch。")])]),t._v(" "),a("h2",{attrs:{id:"async、await-细节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async、await-细节"}},[t._v("#")]),t._v(" async、await 细节")])])}),[],!1,null,null,null);r.default=e.exports}}]);